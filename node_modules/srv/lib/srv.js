// Generated by CoffeeScript 1.4.0
(function() {
  var cluster, defaultOptions, winston, _;

  cluster = require('cluster');

  winston = require('winston');

  _ = require('underscore');

  defaultOptions = {
    worker: {
      count: 4,
      ignoreSigint: true,
      require: 'online',
      timeout: 2000
    },
    recycle: {
      timeout: 15000
    },
    shutdown: {
      timeout: 15000
    },
    restart: {
      delay: 5000
    },
    logger: null
  };

  module.exports = function(options, func) {
    var failedToStart, i, logger, recycle, shutdown, timeouts, worker, _i, _ref, _ref1;
    if (!(func != null)) {
      func = options;
      options = {};
    }
    _.defaults(options, defaultOptions);
    _.defaults(options.worker, defaultOptions.worker);
    _.defaults(options.recycle, defaultOptions.recycle);
    _.defaults(options.shutdown, defaultOptions.shutdown);
    logger = (_ref = options.logger) != null ? _ref : winston.loggers.get('srv');
    if (cluster.isMaster) {
      logger.on('error', function(err) {
        return console.error(err);
      });
      timeouts = {};
      cluster.on('disconnect', function(worker) {
        return logger.info("Worker " + worker.id + " disconnect");
      });
      cluster.on('fork', function(worker) {
        logger.info("Worker " + worker.id + " forked with pid " + worker.process.pid);
        return timeouts[worker.id] = setTimeout((function() {
          return failedToStart(worker);
        }), options.worker.timeout);
      });
      cluster.on('listening', function(worker, address) {
        logger.info("Worker " + worker.id + " listening : " + address.address + ":" + address.port);
        if (worker.id in timeouts) {
          logger.debug("Clearing timeout for " + worker.id);
          clearTimeout(timeouts[worker.id]);
          return delete timeouts[worker.id];
        }
      });
      cluster.on('exit', function(worker, code, signal) {
        logger.info("Worker " + worker.id + " exit: " + code + " " + signal + ". Suicide? " + worker.suicide);
        if (!worker.suicide) {
          logger.warn("Worker " + worker.id + " crashed! Forking new worker...");
          cluster.fork();
        }
        if (Object.keys(cluster.workers).length === 0) {
          logger.info("Graceful exit of all workers. Goodbye!");
          return process.exit(0);
        }
      });
      cluster.on('online', function(worker) {
        logger.info("Worker " + worker.id + " is online ");
        if (options.worker.require === 'online' && worker.id in timeouts) {
          logger.debug("Clearing timeout for " + worker.id);
          clearTimeout(timeouts[worker.id]);
          return delete timeouts[worker.id];
        }
      });
      failedToStart = function(worker) {
        logger.warn("Worker " + worker.id + " failed to start. Retrying...");
        worker.destroy();
        return setTimeout(cluster.fork, options.restart.delay);
      };
      recycle = function() {
        var id, remaining, replace, worker;
        logger.info("Recycle: Starting recycle - this may take some time.");
        remaining = (function() {
          var _ref1, _results;
          _ref1 = cluster.workers;
          _results = [];
          for (id in _ref1) {
            worker = _ref1[id];
            _results.push(worker);
          }
          return _results;
        })();
        replace = function() {
          worker = remaining.pop();
          if (!(worker != null)) {
            logger.info("Recycle: Complete");
            return;
          }
          logger.info("Recycle: Forking");
          cluster.fork();
          return cluster.once(options.worker.require, function() {
            var timeout;
            logger.info("Recycle: New fork ready, shutting down worker");
            timeout = setTimeout((function() {
              logger.warn("Recycle: Took too long - destroying worker " + worker.id);
              return worker.destroy();
            }), options.recycle.timeout);
            worker.disconnect();
            return worker.on('exit', function() {
              logger.info("Recycle: Worker " + worker.id + " exited");
              clearTimeout(timeout);
              return replace();
            });
          });
        };
        return replace();
      };
      shutdown = function() {
        logger.info("Graceful termination");
        cluster.disconnect(function() {
          return logger.info("All workers disconnected.");
        });
        return setTimeout((function() {
          var id, worker, _ref1, _results;
          logger.warn("Took too long to shutdown gracefully, terminating workers.");
          _ref1 = cluster.workers;
          _results = [];
          for (id in _ref1) {
            worker = _ref1[id];
            logger.warn("Destroying worker " + id);
            _results.push(worker.destroy());
          }
          return _results;
        }), options.shutdown.timeout);
      };
      process.on("SIGHUP", function() {
        logger.warn("MasterRecieved SIGHUP");
        return recycle;
      });
      process.on("SIGTERM", shutdown);
      process.on("SIGINT", shutdown);
      for (i = _i = 0, _ref1 = options.worker.count; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        worker = cluster.fork();
      }
      return logger.info("Master ready " + process.pid);
    } else {
      if (options.worker.ignoreSigint) {
        process.on("SIGINT", function() {
          return logger.warn("Worker pid " + process.pid + " ignoring SIGINT");
        });
      }
      return func();
    }
  };

}).call(this);
